## 作用域

1. 分词／词法分析：将我们写的源代码分解成有意义的代码块。
2. 解析／语法分析： 将词法单元流转换成 “抽象语法树”（AST）。
3. 代码生成：将 AST 转换为可执行的代码，转化为机器指令。

- 引擎：从头到尾负责整个 javascript 的编译及执行过程。
- 编译器：负责语法分析及代码生成，为引擎生成运行时所需要的代码。
- 作用域：是一套规则，用于确定在何处以及如何查找变量（标识符）

- LHS 赋值（隐式赋值）：找到变量的容器本身，从而对其赋值，比如说`=2`赋值的目标是谁？
- RHS 取值：查找某个变量的值，源值是什么？

注意：函数传入参数的隐式赋值，未申明的变量赋值在非严格模式下会隐式创建全局变量

- ReferenceError 引用错误，作用域判断失败。比如严格模式下没有声明变量就调用。
- TypeError 作用域判断成功，操作不合法。比如变量调用函数执行。

## 词法作用域

词法作用域是定义在词法分析阶段的作用域，书写代码时变量、函数声明的位置决定的，当然 eval、setTimeout、setInterval、new Function、with 等可以欺骗词法作用域。

无论函数在哪里被调用，也无论它被如何调用，它的词法作用域都只能由`函数被声明时`所处的位置决定。

#### 欺骗词法作用域

也就是动态作用域，程序运行时生成的代码。都会被严格模式所影响。

欺骗词法作用域，导致 javascript 引擎无法在编译时对作用域查找进行优化。

因为 javascript 引擎会在编译阶段进行数项性能优化，有些优化依赖代码的词法进行静态分析，并预先`确定所有变量和函数的位置`，在执行过程中快速找到标识符。欺骗词法作用域会导致关于`标识符位置的判断都是无效的`，所有优化可能都是无意义的，那就不优化了。

1. eval 函数接收一个字符串为参数，在程序执行的时候把字符串当代码执行。eval 常用于动态创建代码。在严格模式下，eval 中的声明不能修改所在作用域。
2. with 根据你传递的对象凭空创建了一个全新的词法作用域。

#### 函数作用域和块级作用域

全局命名空间：全局作用域下第三方库`内部私有函数或变量`很容易引发变量冲突。所以将所有需要暴露给外界的功能都变成整个`对象`（命名空间／模块）的属性。

模块管理：任何库都无需将标识符注入全局作用域，而是通过依赖管理器将库的标识符显式导入到一个`特定的作用域`。利用作用域规则强制所有标识符不能注入到共享作用域中，而是保留在私有作用域中。

函数作用域可以将内部变量和函数隐藏起来，变量只能在函数范围内访问。可以避免变量（同名标识符）冲突。但是`函数本身`污染了函数所在作用域，还必须显式调用`函数名`。
 
__函数表达式__ 不需要函数名（或者至少函数名不会污染全局作用域），并且能自动运行。函数被绑定到函数表达式自身中，而不是正常的函数声明来处理。

匿名函数表达式写起来比较轻便，但也有几个缺点。

1. 匿名函数在堆栈跟踪中不会显示出有意义的函数名，使得调试困难。
2. 如果没有函数名，当函数需要引用自身（递归）只能使用已经过期的 arguments.callee 引用。
3. 代码的可读性下降。

__立即执行函数表达式 IIFE__

常用的匿名函数表达式`(...)()`，将函数放到 第一个 () 中会形成一个表达式，末尾再添加一个 ()，执行这个函数。

注意⚠️：严格意义上 IIFE 并不是闭包，但确实是最常用来创建可以被封闭起来的闭包的工具。IIFE 本身并不会真正创建作用域，它是在定义时所在作用域中执行。
```js
(
  function () { // 匿名
    ...
  }
)();

(
  function IIFE () { // 具名
    ...
  }
)();
```

另一个改进形式`(...())`

```js
(
  function () {
    ...
  }();
)
```

还有一种用法把 IIFE 当作函数调用并传递参数进去

```js
(
  function (global) { // 匿名
    ...
  }
)(window); // 将 window 当作参数传递给 global
```

UMD 通用模块定义 (Universal Module Definition ) 将函数当参数传给表达式

```js
(
  function IIFE (fn) {
    fn(params);
  }
)(
  function (global) {
    ...
  }
);
```

#### 块作用域

块级作用域将代码从函数中隐藏信息扩展为在块中隐藏信息。

```js
 for (var i = 0; i < 10; i++) { 
   // 使用 var 声明 i 时会被绑定在外部作用域（函数或者全局）中
   console.log(i);
 }
```
with 是块级作用域的一种形式。

try／catch 的 catch 分句会创建一个块作用域。其中声明的变量 err 只在 catch 中有效。

let 关键字可以将变量绑定到所在的任意作用域中（通常是在 {...} 内部），换句话就是 let 声明的变量 __隐式的劫持__ 了所在的 __作用域__。但是 let 声明的变量不会进行变量提升。附属于一个新的作用域。

#### 提升

javascript 在编译阶段会找到所有的声明（变量和函数），并用合适的作用域将它们关联起来。

先声明，后赋值。变量和函数声明从代码中出现的位置被移动到 __各自作用域的最顶部__，这个过程叫提升。

- 先提升函数，再提升变量。
- 当变量和函数同名，先提升函数声明，变量声明被忽略。

#### 作用域和闭包

闭包：函数在当前词法作用域外执行。（函数可以访问代码定义时的词法作用域）

闭包会阻止 javascript
 内部的垃圾回收，因为要在函数词法作用域外依然保持该函数作用域的引用。

函数作为第一级的值类型并到处传递，就是闭包的应用。比如定时器、事件监听器、ajax 请求、iframe 通信、web workers、或者同步、异步任务中，只要用到了回调函数，就是在使用闭包。

```js
for (var i =1; i <= 5; i++) {
  setTimeout(
    function timer () { 
      console.log(i);
    }, 1000);
}
```

上面的例子中，根据作用域的工作原理，上面的 5 个函数都被封闭在一个共享的全局作用域中，因此所有函数共享一个 i 的引用 。

```js
for (var i =1; i <= 5; i++) {
  (function (i) { // 通过 IIFE，为每一次迭代都创建一个新的作用域，接收传递的 i
    setTimeout(
      function timer () { // 延迟函数 setTimeout 的回调 timer 执行的就是新的作用域；
        console.log(i); 
      }, 1000);
  })(i);// 如果作用域是空的，光封闭作用域也不行，那就将 i 传进去
}
```

在迭代内部使用 IIFE 为每个迭代都生成一个新的作用域，使延迟函数 setTimeout 可以将新的作用域封闭在每个迭代内部，每个迭代再接受一个正确的变量提供访问。

```js
for (var i =1; i <= 5; i++) {
  let j = i; // let 劫持了当前作用域
  setTimeout(
    function timer () { 
      console.log(j);
    }, 1000);
}

for (let i =1; i <= 5; i++) { // for 循环头部的 let 声明是一种特殊行为，没迭代一次就声明一次，每次迭代结束的值都用来初始化下一个变量
  setTimeout(
    function timer () { 
      console.log(i);
    }, 1000);
}
```

#### 模块

模块实例化返回的对象含有对内部函数的引用，返回值将内部函数传递到词法作用域外时，是实现闭包的条件之一，因为还没执行。而内部变量是隐藏且私有的状态。当然模块也是函数，可以接受参数。

模块模式 2 个必要条件：

1. 必须由外部的封闭函数，至少要`执行`一次，每次执行都是新的模块实例。
2. 封闭函数必须返回一个内部函数，能在`词法作用域外`执行目标函数，这样才能形成闭包。并且可以`访问或修改内部变量`，也就是从模块实例内部对模块实例进行修改。

特点：调用包装函数（内部有函数定义），并将返回值作为该模块的 API。

编译器无法识别基于函数的模块（函数闭包形成的模块），只有在执行的时候才被考虑进来，所以在运行时才能修改 API。

编译器可以识别 ES6 模块 API ，因为是静态的编译器检查导入模块 API 成员是否存在，不存在就抛出错误，而不会等运行时再动态解析（并报错）。

ES6 没有行内格式，所以每个独立的文件就是一个模块。import 导入模块，export 导出模块

#### 作用域链

作用域链是基于调用栈的，而不是代码中的词法作用域嵌套。
词法作用域是代码定义时确定的，动态作用域是代码执行时确定的，如 this。

try/catch会延长作用域链，导致性能问题。