# 数据结构与算法

### 概念

- 数据：能够被数据化（照片、视频）
- 数据对象：能完整的描述一个东西（栈、队列、链表）
- 数据元素：组成数据对象的单位（一份一份的数据）
- 数据项：数据结构中的最小单位，不能再拆分了，再拆分就没有意义了。

把数据对象比做班级，数据元素就是班级里的学生，数据项就是学生的特长

## 数据结构

数据相互之间的关系，称为结构。算法是对数据的操作。

- 按逻辑分类，元素之间的逻辑关系（抽象，用来描述）。
- 按存储结构分类，数据结构在计算机中的表示（具体，实现抽象逻辑）。

#### 逻辑结构

1. 离散结构，没有逻辑关系（集合）
2. 线性结构，有先后关系，且是连续性的（栈、队列、一维数组）
3. 非线性结构（树、图、多维数组）。

有 4 种基本逻辑结构：

- 集合：在 JavaScript 里面是 Set
- 线性结构：线性表有两种实现方式，一种是顺序表，一种是链表
- 树状结构：组织架构
- 图结构(网状结构)：人际关系

#### 存储结构：

- 顺序结构：连续的
- 链式结构：底层是指针，需要手动申请内存，释放内存。高级语言都是引用。
- 索引结构：哈希表
- 散列结构：

##### 集合：类似于数据中的集合，特点是无序的，数据中的成员不能重复。

##### 线性表：元素和元素是一对一的关系，用来存放某一类型的元素。

表面上看上去不一样，但面向对象都是继承的，必须要有相同的基类。在 JS 当中，所有的数据都是对象。

顺序表：

- 优点：遍历简单，节省内存。
- 缺点：内存没法缩放，数据想变就要重新申请内存，把数据移动过去。

链表：分单向链表和双向链表，“前驱指针”和“后继指针”都占内存。

- 优点：灵活一些，数据变化，内存操作量小。
- 缺点：遍历的时候复杂一些，占用内存。

##### 线性表的衍生结构

- 栈
- 队列
- 串

数据的 4 种基本操纵，增删改查，查就是遍历。线性表可以从任意部分操作数据。

栈：操作受限的线性表，只能操作 `栈顶`，后进先出（Last In First Out）。
- 比如桶装薯片，装的时候从底往上装，拿的时候从上往下拿。
- 常用场景，JS的函数执行栈。

队列：操作受限的线性表，可以操作 `队首队尾`，先进先出（First In First Out）。

- 比如车站排队买票，先来先买。
- 当然也有 `优先队列` 比如车站排队，军人优先。
- 还有 `环形队列`，比如通信领域，需要轮询的时候。

串：字符串和字节流，操作子串。

#### 树

由有限`节点`组成的一个`有层次关系`的`集合`。

- 根节点
- 父节点
- 子节点
- 叶子节点
- 深度
- 路径

树的遍历：

- 广度优先遍历
- 深度优先遍历

    - 先序遍历：根结点 ---> 左子树 ---> 右子树
    - 中序遍历：左子树---> 根结点 ---> 右子树
    - 后序遍历：左子树 ---> 右子树 ---> 根结点

注意⚠️：

- `左子树`是`最左边`的`最深层次`的节点。
- 可以有空集、空表、空树，不能有空图。

#### 图

- 顶点
- 边
- 权

## 算法

算法是完成某个特定任务的过程。

#### 算法的特征

1. 有穷性：必须能终止。

2. 确切性：每一步都必须有确切的定义。

3. 输入项：输入初始条件，所谓0个输入是指`算法本身定义`了初始条件。（把函数看作算法）

4. 输出项：至少有一个输出，没有输出的算法毫无意义。

5. 可行性：暴力破解密码，用一百年破译密码，没有意义。

#### 算法的好坏

1. 复杂度

    - 时间复杂度：耗费多久时间
    - 空间复杂度：额外消耗的存储空间

2. 正确性

3. 可读性：别人能不能看懂，看不懂也就没法验证

4. 健壮性：稳定性，边界情况的处理

#### 算法复杂度

数据规模必须大于 1

- `常数阶 O(1)` ---> 哈希表
- `对数阶 O(logN)`
- `线性阶 O(n)` ---> React的虚拟DOM
- `线性对数阶 O(nlogN)`
- `平方阶 O(n^2)`
- `立方阶 O(n^3)`
- `k次方阶 O(n^k)`
- `指数阶O(2^n)`

#### 计算复杂度：

随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越低。

- 有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推。
- 如果有二分，则为O(logN)。
- 保留最高项，去除常数项。

假如算法复杂度为 `1+n+n+n`, 保留最高项，去除常数项为 `O(n)`

#### 基本算法

- 枚举
- 递归
- 基本排序
- 基本查找

##### 枚举算法

枚举所有的可能，类似于暴力破解法。

速度可能很慢，但是实现最简单，是我们应该优先考虑的，然后再考虑优化。

#### 递归算法

将问题分解为同类的子问题。

比如自己调用自己，递归可以取代循环。递归一定要有退出条件。

#### 排序算法

#### 查找算法

注意⚠️：
- 一般常说的时间复杂度，指的是平均时间复杂度
- 稳定性，并不是说算法稳定性，而是算法的结果都是对的，但是结果不唯一。