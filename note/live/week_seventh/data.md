# 数据结构与算法

### 概念

- 数据：能够被数据化（照片、视频）
- 数据对象：能完整的描述一个东西（栈、队列、链表）
- 数据元素：组成数据对象的单位（一份一份的数据）
- 数据项：数据结构中的最小单位，不能再拆分了，再拆分就没有意义了。

把数据对象比做班级，数据元素就是班级里的学生，数据项就是学生的特长

## 数据结构

数据相互之间的关系，称为结构。算法是对数据的操作。

- 按逻辑分类，元素之间的逻辑关系（抽象，用来描述）。
- 按存储结构分类，数据结构在计算机中的表示（具体，实现抽象逻辑）。

#### 逻辑结构

1. 离散结构，没有逻辑关系（集合）
2. 线性结构，有先后关系，且是连续性的（栈、队列、一维数组）
3. 非线性结构（树、图、多维数组）。

有 4 种基本逻辑结构：

- 集合：在 JavaScript 里面是 Set
- 线性结构：线性表有两种实现方式，一种是顺序表，一种是链表
- 树状结构：组织架构
- 图结构(网状结构)：人际关系

#### 存储结构：

- 顺序结构：连续的
- 链式结构：底层是指针，需要手动申请内存，释放内存。高级语言都是引用。
- 索引结构：哈希表
- 散列结构：

##### 集合：类似于数据中的集合，特点是无序的，数据中的成员不能重复。

##### 线性表：元素和元素是一对一的关系，用来存放某一类型的元素。

表面上看上去不一样，但面向对象都是继承的，必须要有相同的基类。在 JS 当中，所有的数据都是对象。

顺序表：

- 优点：遍历简单，节省内存。
- 缺点：内存没法缩放，数据想变就要重新申请内存，把数据移动过去。

链表：分单向链表和双向链表，“前驱指针”和“后继指针”都占内存。

- 优点：灵活一些，数据变化，内存操作量小。
- 缺点：遍历的时候复杂一些，占用内存。

##### 线性表的衍生结构

- 栈
- 队列
- 串

数据的 4 种基本操纵，增删改查，查就是遍历。线性表可以从任意部分操作数据。

栈：操作受限的线性表，只能操作 `栈顶`，后进先出（Last In First Out）。
- 比如桶装薯片，装的时候从底往上装，拿的时候从上往下拿。
- 常用场景，JS的函数执行栈。

队列：操作受限的线性表，可以操作 `队首队尾`，先进先出（First In First Out）。

- 比如车站排队买票，先来先买。
- 当然也有 `优先队列` 比如车站排队，军人优先。
- 还有 `环形队列`，比如通信领域，需要轮询的时候。

串：字符串和字节流，操作子串。

#### 树

由有限`节点`组成的一个`有层次关系`的`集合`。

- 根节点
- 父节点
- 子节点
- 叶子节点
- 深度
- 路径

树的遍历：

- 广度优先遍历
- 深度优先遍历

    - 先序遍历：父节点 ---> 左节点 ---> 右节点
    - 中序遍历：左节点 ---> 父节点 ---> 右节点。以 3 个节点为周期，从`最小到最大`的顺序遍历。
    - 后序遍历：左节点 ---> 右节点 ---> 父节点
   
注意⚠️：

- `左节点`是 "先左再深"，`最左边`的`最深层次`的节点。
- 3 个节点周期里最小到最大是左节点 ---> 父节点 ---> 右节点。
- 可以有空集、空表、空树，不能有空图。

#### 图

- 顶点
- 边
- 权

## 算法

算法是完成某个特定任务的过程。

#### 算法的特征

1. 有穷性：必须能终止。

2. 确切性：每一步都必须有确切的定义。

3. 输入项：输入初始条件，所谓0个输入是指`算法本身定义`了初始条件。（把函数看作算法）

4. 输出项：至少有一个输出，没有输出的算法毫无意义。

5. 可行性：暴力破解密码，用一百年破译密码，没有意义。

#### 算法的好坏

1. 复杂度

    - 时间复杂度：耗费多久时间
    - 空间复杂度：额外消耗的存储空间

2. 正确性

3. 可读性：别人能不能看懂，看不懂也就没法验证

4. 健壮性：稳定性，边界情况的处理

#### 算法复杂度

数据规模必须大于 1

- `常数阶 O(1)` ---> 哈希表
- `对数阶 O(logN)`
- `线性阶 O(n)` ---> React的虚拟DOM
- `线性对数阶 O(nlogN)`
- `平方阶 O(n^2)`
- `立方阶 O(n^3)`
- `k次方阶 O(n^k)`
- `指数阶O(2^n)`

#### 计算复杂度：

随着问题规模 n 的不断增大，时间复杂度不断增大，算法的执行效率越低。

- 有几重循环，一般来说一重就是O(n)，两重就是 O(n^2)，以此类推。
- 如果有二分，则为O(logN)。
- 保留最高项，去除常数项。

假如算法复杂度为 `1+n+n+n`, 保留最高项，去除常数项为 `O(n)`

#### 基本算法

- 枚举
- 递归
- 基本排序
- 基本查找

##### 枚举算法

枚举所有的可能，类似于暴力破解法。

速度可能很慢，但是实现最简单，是我们应该优先考虑的，然后再考虑优化。

#### 递归算法

将问题分解为同类的子问题。

比如自己调用自己，递归可以取代循环。递归一定要有退出条件。

#### 排序算法

- 冒泡排序：两层循环，外循环用来控制次数，内循环`俩俩交换`用来交换两个数的较大值，选出本层循环最大值，从大往小。
- 选择排序：两层循环，外循环用来控制次数，内循环`选出最小值`，用比较最小值的方式，选出本层循环最小值，从小往大。
- 插入排序：两层循环，外循环用来控制次数，内层循`通过比较前后两个数`，从第二个数开始`选择插入`当前数的位置。
- 归并排序：`一层循环+分治法` 通过二分法递归直到每个数组长度为 1，通过`循环比较`左侧数组所有项和右侧数组所有项大小，然后从小到大添加到临时的大数组。
- 快速排序：`一层循环+分治法`，选择主元，创建两个指针，移动左指针找到比主元大的元素（或者等于），然后移动右指针找到比主元小的元素（或者等于），然后交换，如过左指针越过右指针则本轮结束。然后循环操作。
- 堆排序：把数组当成二叉树来排序。第一个元素表示根节点，类似广度优先遍历那样分布。
- 计数排序、桶排序、基数排序

#### 查找算法

- 顺序搜索，最基本的搜索算法，比较低效
- 二分搜索，选取中间值做比较。

注意⚠️：
- 一般常说的时间复杂度，指的是平均时间复杂度
- 稳定性，并不是说算法稳定性，而是算法的结果都是对的，但是结果不唯一。

#### 算法思维

- 化繁为简（数学归纳法）
- 分而治之（一分为二）问题是否可以简化，整体问题是否被简化了。
- 化实为虚（逆向思维）使用另外一种形式进行替换


#### 列表

迭代器的优点：

- 访问元素时不必关心底层数据结构
- 增加和删除的时候比for要更加灵活

#### 栈

栈是一中特殊的列表，栈是一种高效的数据结构，因为只能从栈顶增加和删除，操作很快

#### 链表

数组并不是数据的最佳结构，数组一般是固定的，删除或插入操作的时候，需要对其他数据进行移动。

链表是关系引用的，除了对数据的随机访问，链表几乎可以替代一维数组。

#### 字典

就是键值对

#### 散列

散列的数据可以快速的插入、删除、取用，查找效率低下

散列表（哈希表）：类似于不连续的数组`[0,undefiend,undefiend,3]`

散列集合：插入，移除或获取元素时，用的都是散列函数。散列集合只存储唯一的不重复的值。

散列函数可能会算出一样的 key，这时候就需要解决`散列表中冲突`了。

处理冲突的方法：

1. 分离链接，在散列表中创建一个`链表`,将元素存到里面。缺点：需要占据额外的存储空间。
2. 线性探查
3. 双散列法

#### 二叉树

将较小的值放到了左节点，较大的值放到了右节点。

#### 堆栈

- 栈：存放 6 种基本类型和 `object 的引用`，大小 8 M。

    - undefined
    - null
    - string
    - number
    - boolean
    - symbol

- 堆：存放复杂类型 object

    - 内置对象 new 出来的变量
    - 栈中需要保存对堆中变量的 __引用__
    - js 的闭包都是存在`堆`里的

同步叫执行栈，异步叫执行队列，（队列可以有优先级）

- 爆栈，是栈放不下，大小超过 8M 。
- 死循环，是当前函数不会出栈, 其他函数没法执行。