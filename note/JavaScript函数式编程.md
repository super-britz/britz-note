## 函数式编程

#### 什么是函数式编程？
函数式编程是一种编程范式，范畴论的运算方法，是一种`数学运算`，原始目的就是求值，只是碰巧它能用来写程序。
1. 函数是一等公民，和其他数据类型一样，可以赋值给其他变量，也可以作为函数参数和函数返回值
2. 只用`表达式`，不用`语句`, 因为数学里面有表达式，没有 if..else... 这种语句
3. 没有副作用
4. 不修改状态
5. 引用透明（函数运行只依赖参数）

#### 函数式编程常用核心理念

##### 专业术语：

纯函数：降低复杂度，可以缓存
1. 相同输入总是会返回相同的输出，不管上下文是什么，不管你调用多少次，或者什么时候调用，返回值都是一样的（可以缓存）  
2. 不可变性，不产生副作用，不能改变任何外部状态（console、redux、引用传递...）  
3. 也不依赖外部环境状态（redux...）

函数的柯里化：偏函数的应用，像洋葱代码 h(g(f(x)));  
1. 偏函数，将多个入参的函数转化成两部分，一步是函数，一步是参数（2 步）
2. 柯理化，把一个有 n 个参数的函数，变成 n 个只有 1 个参数的函数（n 步）

函数组合：将两个函数结合，产生一个新的函数，创建了一个从右到左的数据流，范畴论数学中的结合律，解决了函数嵌套，洋葱代码 h(g(f(x))); 的问题。

Point Free: 把一些对象自带的方法转化为纯函数，不要命名转瞬即逝的中间变量

声明式与命令式代码：
1. 声明式编程：告诉“机器”你想要的是什么，让机器想出如何去做，强调整体。
2. 命令式编程：命令“机器”如何去做事情，这样不管你想要的是什么，它都会按照你的命令实现，强调过程。

惰性求值、惰性函数、惰性链：
1. 惰性求值式一种按需求值机制，尽可能的延迟求值，直到依赖的表达式被调用，避免不必要的运算。
2. 贪婪求值（及早求值）会在表达式绑定到变量时求值，不管结果是否被用到。
3. [惰性函数](https://github.com/mqyqingfeng/Blog/issues/44)
4. 惰性链：类似于先链式调用，再惰性求值

##### 更加专业的术语：

高阶函数：把函数当参数，把传入的函数做一个封装，然后返回这个封装的函数，达到更高程度的抽象。

尾调用优化：尾递归优化是尾递归的一种
1. 递归：函数调用自身，需要包存大量的调用栈记录，很容易发生堆栈溢出错误
3. 尾调用：一个函数的`最后一步`（不取决与最后一行）是调用另一个函数。
3. 尾递归：函数`最后一行`调用自身
4. 尾调用优化：尾调用自身，
函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。所有的调用记录，形成一个"调用栈"（call stack）。
尾调用优化由于是函数的最后一步操作，调用位置、内部变量等信息都不会再用到了，所以不需要保留外层函数的调用记录，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。
5. 现如今的浏览器并未完全支持尾调用优化  
1⃣️ 在引擎层面消除递归是一个隐式的行为  
2⃣️ 堆栈信息消失了，开发者难以调试  
3⃣️ 既然浏览器不支持我们可以把这些递归写成 while，throw Error  
6. 死循环和堆栈溢出，内存泄漏  
1⃣️ 堆栈：抽象数据类型，特性：LIFO 队列（后进先出）  
2⃣️ 堆栈溢出：由于过多的函数调用，导致调用堆栈无法容纳这些调用的返回地址，说白了堆栈就是放不下，溢出了，一般出现在无限递归中。  
3⃣️ 死循环：无法靠自身的控制终止的循环，但并非所有死循环都会导致堆栈或者内存溢出，只要给死循环一个提示，终止循环就好了。   
4⃣️ 内存泄漏：指由于疏忽或错误造成程序未能释放已经不再使用的内存，说白了就是内存用完没用释放，导致可用内存越来越少，比如不合理的使用闭包。

闭包：一种能够在函数声明过程中将`环境信息`与`所属函数`绑定到一起的数据结构。
```js
// 如下例子，虽然外层的 makePowerFn 函数执行完毕
// 栈上的调用帧被释放，但是堆上的作用域并不被释放
// 因此 power 依旧可以 被 powerFn 函数访问，这样就形成了闭包
function makePowerFn(power) {  
  function powerFn(base) { 
    return Math.pow(base, power);  
  } 
  return powerFn;  
} 
var square = makePowerFn(2);   square(3); // 9
```

范畴（容器）: 包含两样东西 `值（value）`、`值的变形关系（函数）`，范畴论用函数表达范畴间的关系，创建一个安全的容器，来存放危险代码。

Functor（函子）: 首先是一种范畴（容器），包含值和变形关系。函数编式程里`映射函数的数据类型`，也是函数式编程的基本运算单位和功能单位。  
Functor 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数， 这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性
- 一般约定，函子有一个 of 方法，用来生成新的容器。
- 一般约定，函子的标志就是容器具有 map 方法。该方法将容器 里面的每一个值，映射到另一个容器。

函数式编程里面的运算，都是通过函子完成， 即运算不直接针对值，而是针对这个值的容器----函子。函子本 身具有对外接口 (map 方法），各种函数就是运算符，通过接口 接入容器，引发容器里面的值的变形
- Maybe：Maybe 函子的 map 方法里面设置了空值检查。   
函子接受各种函数，处理容器内部的值。容器内部可能是 空值 null，外部未必有处理空值 null 的机制，如果传入空值，很可能就会出错。
- 错误处理： try catch／throw 不纯，try catch 会延长作用域链
- Either： Either 函子的常见用途是提供默认值（利用三元表达式）。  
Either 函子内部有两个值：左值 (Left) 和右值 (Right)。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。
- AP： AP 函子处理值是函数的情况。  
AP 是 applicative（应用的缩写），一个函子的值是数值，另一个函子的值是函数。通过 AP 函子就可以实现函子的链式操作。
- IO： Monad 函子的重要应用，就是实现 I/O （输入输出）操作。  
I/O 是不纯的操作，比如读取文件和打印文件，普通的函数式编程没法做，这时就需要把 IO 操作写成 Monad 函子，通过它来完成。
- ...

Monad: 总是返回一个单层的函子。  
Monad 函子有一个 flatMap 方法，如果生成了一个嵌套函子，flatMap 会`取`出 map 内部的`值`，保证返回的永远是一个单层的容器，不会出现嵌套的情况。  
Monad 就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。比如 Promise 就是一种 Monad ，让我们避开了嵌套地狱，可以轻松的进行深度嵌套的函数式编程。

##### 流行的几大函数式编程库

- RxJS
- cycleJS 
- lodashJS、lazy（惰性求值） 
- underscoreJS
- ramdajs