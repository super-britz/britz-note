#### 前端常用设计模式

能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。所谓“不变的东西”，说的就是驾驭技术的能力。

- 能用健壮的代码去解决具体的问题；
- 能用抽象的思维去应对复杂的系统；
- 能用工程化的思想去规划更大规模的业务。

在我入行以来接触过的工程师里，能做到第一点，并且把它做到扎实、做到娴熟的人，已经堪称同辈楷模。

设计模式的核心思想，就是“封装变化”

SOLID设计原则

单一功能原则（Single Responsibility Principle）
开放封闭原则（Opened Closed Principle）
里式替换原则（Liskov Substitution Principle）
接口隔离原则（Interface Segregation Principle）
依赖反转原则（Dependency Inversion Principle）


创建型、结构型还是行为型
- 创建型模式封装了创建对象过程中的变化
- 结构型模式封装的是对象之间组合方式的变化， 目的在于灵活地表达对象间的配合与依赖关系
- 行为型模式则将是对象千变万化的行为进行抽离，确保我们能够更安全、更方便地对行为进行更改。

设计模式的核心操作是去观察你整个逻辑里面的变与不变，然后将变与不变分离，达到使变化的部分灵活、不变的地方稳定的目的。


#### 构造器模式

在 JavaScript 中，我们使用构造函数去初始化对象，就是应用了构造器模式。

构造器将赋值给对象的过程进行了封装，确保了每个对象都具备这些属性，确保了共性的不变。对各自的取值操作开放，确保了个性的灵活。

在使用构造器模式的时候，我们本质上是去抽象了每个对象实例的变与不变。

####　工厂模式

抽象不同构造函数（类）之间的变与不变。

简单工厂其实就是将创建对象的过程单独封装。无脑传参，屏蔽具体的实现，调用者只关心接口和接口的入参即可。

开放封闭原则的内容：对拓展开放，对修改封闭。说得更准确点，软件实体（类、模块、函数）可以扩展，但是不可修改。

抽象工厂不干活，具体工厂（ConcreteFactory）来干活！

抽象工厂修改封闭，具体工厂拓展开放，对原有的系统不会造成任何潜在影响。

抽象工厂和简单工厂：都尝试去分离一个系统中变与不变的部分。抽象工厂是佐证“开放封闭原则”的良好素材

- 抽象工厂（抽象类，它不能被用于生成具体实例）
- 具体工厂（ 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的类）



#### 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。（可以通过构造函数、静态方法、闭包 3 种来判断实现）

单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。

要做到这一点，就需要构造函数具备判断自己是否已经创建过一个实例的能力。

Vuex 通过单例模式确保 Store的唯一性, 失去了单例判断能力的 install 方法，会为当前的Vue实例重新注入一个新的 Store，

也就是说你中间的那些数据操作全都没了，一切归 0。因此，单例模式在Vuex是非常必要的。

单例模式有点像是植于程序内部的类缓存机制。

闭包最主要的目的：提供访问函数内部 local variables 的途径。



#### 原型模式

原型模式不仅是一种设计模式，它还是一种**编程范式**（programming paradigm），是 JavaScript 面向对象系统实现的根基。

- 以类为中心的语言 Java
- 以原型为中心的语言 JavaScript

在原型模式下，当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过**克隆原型**的方式来创建出一个与原型一样（共享一套数据/方法）的对象。

**深拷贝没有完美方案，每一种方案都有它的边界 case**。

实现 JavaScript 中的深拷贝，有一种非常取巧的方式 —— JSON.stringify，只有当你的对象是一个严格的 JSON 对象时，可以顺利使用这个方法。

多数情况下，面试官只是希望考查你对**递归**的熟练程度。除了考虑 Array、Object，还需要考虑一些其它的数据结构（Map、Set 等）



#### 装饰器模式

装饰器模式，又名装饰者模式。它的定义是“在不改变原对象的基础上，通过对其进行包装拓展，使原有对象可以满足用户的更复杂需求”。

装饰器**Decorator**的最基本操作——定义装饰器函数，将被装饰者“交给”装饰器。这也正是ES7装饰器语法糖首先帮我们做掉的工作 —— 函数传参&调用。

装饰器函数执行的时候，Button 实例还并不存在。这是因为实例是在我们的代码**运行时**动态生成的，而装饰器函数则是在**编译阶段**就执行了。所以说装饰器函数真正能触及到的，就只有类这个层面上的对象。

**React中的装饰器：HOC** 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。

通过编写高阶组件，我们可以充分复用现有逻辑，提高编码效率和代码的健壮性。

```js
// 把App组件与Redux绑在一起
export default connect(mapStateToProps, mapDispatchToProps)(App)

// mapStateToProps 是一个函数，它可以建立组件和状态之间的映射关系；
// mapDispatchToProps 也是一个函数，它用于建立组件和store.dispatch的关系，使组件具备通过 dispatch 来派发状态的能力。
```



#### 适配器模式

适配器模式通过**把一个类的接口变换成客户端所期待的另一种接口**，可以帮我们解决**不兼容**的问题。

**axios **在浏览器和Node环境下完美地 **抹平了两种环境下api的调用差异**，靠的正是对适配器模式的灵活运用。

**axios **一个好的适配器的自我修养——把变化留给自己，把统一留给用户。



#### 代理模式

**通过访问VPN**  比起常规的访问过程，多出了一个第三方 —— **代理服务器**。这个第三方的 ip 地址，不在被禁用的那批 ip 地址之列，我们可以顺利访问到这台服务器。而这台服务器的 DNS 解析过程，没有被施加咒语，所以它是可以顺利访问 Google.com 的。代理服务器在请求到 Google.com 后，将响应体转发给你，使你得以间接地访问到目标网址 —— 像这种第三方代替我们访问目标对象的模式，就是代理模式。

业务开发中最常见的四种代理类型：**事件代理、虚拟代理、缓存代理和保护代理**。

**事件代理**

- 父元素对事件进行处理和分发、间接地将其作用于子元素。
- **React 事件机制**给document注册原生事件回调为dispatchEvent（统一的事件分发机制）

**虚拟代理**

- **图片懒加载**，采取“先占位、后加载”的方式来展示图片 —— 在元素露出之前，我们给它一个 div 作占位，当它滚动到可视区域内时，再即时地去加载真实的图片资源，这样做既减轻了性能压力、又保住了用户体验。

- **图片预加载**，“先下载然后缓存、后展示”，主要是为了避免网络不好、或者图片太大时，页面长时间给用户留白的尴尬。

**缓存代理** 用空间换时间，针对大量入参、做反复计算时，缓存代理的优势将得到更充分的凸显。

**保护代理** 

- 就是在访问层面做文章，在 getter 和 setter 函数里去进行校验和拦截，确保一部分变量是安全的。

- Proxy，它本身就是为拦截而生的，所以我们目前实现保护代理时，考虑的首要方案就是 ES6 中的 Proxy。



#### 策略模式

策略模式：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

“封装”就是把某一功能点对应的逻辑给提出来；“可替换”建立在封装的基础上，只是说这个“替换”的判断过程，咱们不能直接怼 if-else，而要考虑更优的映射方案。

**if-else 侠，人人喊打 **

- 违背了“单一功能”原则
- 如果其中一行出了问题，整个逻辑都会有问题，bu定位也不清晰
- 很难被抽离复用

if-else，目的到底是什么？是不是确定 **对象映射** 关系！



#### 状态模式

状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。

**策略与状态的辨析**

策略模式和状态模式确实是相似的，它们都封装行为、都通过委托来实现行为分发。

- 策略模式是对算法的封装。
  - 算法和状态对应的行为函数虽然本质上都是行为，但算法明显比行为的独立性高。
  - 策略模式的行为函数，是对算法的封装，不依赖调用主体、互相平行、各自为政，井水不犯河水。
  - 只要关注计算逻辑本身。
- 状态模式中的行为函数，需要关心过程，须对主体有感知才行。
  - 行为函数和状态主体之间存在着关联，由状态主体把它们串在一起，不同状态对应的行为函数可能并不会特别独立。
  - 可以将状态对应的行为抽象成类，通过传递 this 的方式来关联状态和状态主体，比较麻烦。
  - 运用策略模式，把状态-行为对象映射，作为主体实例的一个属性添加进去就行了，注意this指向就好，比较简单。



#### 观察者模式（发布 - 订阅者模式）

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

**发布者指责：添加、移除、通知订阅者**

**订阅者指责：被通知、去执行**

在Vue数据双向绑定的实现逻辑里，有这样三个关键角色：

- observer（监听器）：注意，此 observer 非彼 observer。在我们上节的解析中，observer 作为设计模式中的一个角色，代表“订阅者”。但在Vue数据双向绑定的角色结构里，所谓的 observer 不仅是一个数据监听器，它还需要对监听到的数据进行**转发**——也就是说它**同时还是一个发布者**。
- watcher（订阅者）：observer 把数据转发给了**真正的订阅者**——watcher对象。watcher 接收到新的数据后，会去更新视图。
- compile（编译器）：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管~
  这三者的配合过程如图所示：

**在 Vue 中使用 Event Bus 来实现组件间的通讯**（发布-订阅者模式）

Event Bus/Event Emitter 作为全局事件总线，**new Vue() **它起到的是一个**沟通桥梁**的作用。我们可以把它理解为一个事件中心，我们所有事件的订阅/发布都不能由订阅方和发布方“私下沟通”，必须要委托这个事件中心帮我们实现。

**观察者模式与发布-订阅模式的区别是什么？**

- 两者在核心思想、运作机制上没有本质的差别。
- **发布者直接触及到订阅者**的操作，叫观察者模式
- **发布者不直接触及到订阅者**而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式。

观察者模式，解决的其实是模块间的耦合问题，有它在，即便是两个分离的、毫不相关的模块，也可以实现数据通信。但观察者模式仅仅是减少了耦合，**并没有完全地解决耦合问题**——被观察者必须去维护一套观察者的集合，这些观察者必须实现统一的方法供被观察者调用，两者之间还是有着说不清、道不明的关系。

而发布-订阅模式，则是快刀斩乱麻了——发布者完全不用感知订阅者，不用关心它怎么实现回调方法，事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上。发布-订阅模式下，实现了完全地解耦。



#### 迭代器模式

迭代器模式提供一种方法顺序访问一个**聚合对象**（Array、TypedArray、Object、Map、Set）中的各个元素，而又不暴露该对象的内部表示。

迭代器模式是设计模式中少有的**目的性极强的模式**。所谓“目的性极强”就是说它不操心别的，它就解决这一个问题——**遍历**。

ES6在推出新数据结构 Map、Set 的同时也推出了一套**统一的接口机制**——迭代器（Iterator）

ES6约定，任何数据结构只要具备Symbol.iterator属性（这个属性就是Iterator的具体实现，它本质上是当前数据结构默认的迭代器生成函数），就可以被遍历——准确地说，是被for...of...循环和迭代器的next方法遍历。 事实上，for...of...的背后正是对next方法的反复调用。

在ES6中，针对Array、Map、Set、String、TypedArray、函数的 arguments 对象、NodeList 对象这些原生的数据结构都可以通过for...of...进行遍历。

ES6内置了贴心的**生成器(Generator)**供我们使用：

```js
// 编写一个迭代器生成函数
function *iteratorGenerator() {
    yield '1号选手'
    yield '2号选手'
    yield '3号选手'
}

const iterator = iteratorGenerator()

iterator.next()
iterator.next()
iterator.next()
```





