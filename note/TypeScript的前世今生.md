#### TypeScript前世今生
----------------------

##### node.js 

催生 typescript 的原因

+ 有模有样的后端语言
+ 3千万的pv都没问题
+ 大量的闭包、回调、内存浪费、全站崩溃(var a = 1, 等于1忘写了，可能就全站崩溃)
+ 面向过程的观念无法改变
+ 对于继承、或者接口interface一听就迷糊，

#####  正规语言的心经

TypeScript是 javascript 的超集，本质上向 javascript 添加了可选的静态类型和基于类的面向对象编程

1. 强类型的编程语言, 显式声明字符串

	- 改变类型，内存受伤，极大浪费

2. 常量、变量、作用域、this、可空数组、真实数组、结构、枚举

	- 常量节省空间，代码都在内存里、
	- 变量要指定类型、
	- js作用域很奇葩的，其他语言块级作用域，像监狱一样，出去就打你，就不要了
	- js的this变来变去的，其他语言this就指向当前的class，不变
	- 可空类型
	- 真实数组，js的数组是对象，进栈出栈对象会慢
	- 结构 是个壳子，需要去添 类型
	- 枚举 是个集合 类型

3. 面向对象编程、类、继承、多态、接口、命名空间、变量的修饰、构造函数、访问器(Get、Set)、静态属性
	
	其他语言都有
	- class
	- extends
	- 多态，不同的变量类型，不同的function
	- 接口 只是负责声明不实现，做抽象，能够迅速分析出要做的事情，基于接口可以实现无数个类
	- 命名空间 
	
	``` javascript
		var s = {};
		s.get = function(){}
		// 模拟命名空间
	```
	
	- public 私有 
	- constructor 执行类的时候，自动执行constructor
	- 访问器 先Set再Get
	- 静态属性
	
4. 委托、泛型、反射、集合 (动态数组 ArrayList/Hashtable/SortedList/Stack/Queue)、匿名函数、拆箱

	- 委托 div绑定事件20个 引擎去找，再绑定, 委托body找target
	- 泛型 随意的类型
	- 反射 找到所有类里面的数据，动态化
	- 集合 数据结构，实现了所有数据结构的高级动态语言
	- 拆箱 比如es6的import 拆箱封箱 编程语言统一化的思想

5. 多线程
	分析系统底层的内存到底是干嘛的
	web worker