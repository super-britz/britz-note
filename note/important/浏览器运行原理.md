## 浏览器工作原理

### 浏览器主要组成

- **User Interface** 
- **Browser Engine**
- **Rendering Engine**
- **Network**
- **UI Backend**
- **JavaScript Interpreter**
- **Data Storage**

### Webkit 渲染引擎主流程

1. 开始解析 HTML ，转化成DOM树，同时也会解析 CSS ，CSSOM规则树
2. 将DOM树与CSSOM规则树合并在一起生成 Render 树。
3. 遍历 Render 树开始 reflow，计算每个节点的位置大小信息。
4. 将 Render 树每个节点 repaint 到屏幕。

注意：script 标签会阻止 HTML 解析，如果 JS 还操作了 CSSOM，那就必须先下载和构建 CSSOM。

display:none 不会在 reader tree 中，visibility:hidden 在 reader tree 中。

Firefox 在样式表加载和解析的过程中，会禁止所有脚本。

WebKit 仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

#### 1. 解析 Parsing

解析的过程可以分成两个子过程：词法分析和语法分析。

- 词法分析：负责将输入内容分解成一个个有效标记。
- 语法分析：负责根据语言的语法规则分析文档的结构，从而构建 Parse 树。

解析是一个迭代的过程，解析器会向词法分析器请求一个新标记，尝试将其与某条语法规则进行匹配。

- 匹配成功：将标记节点添加到解析树中
- 匹配失败：将标记存储到内部，并继续请求标记。
- 如果找不到任何匹配规则，解析器就会引发一个异常，也就是语法错误。

**编译 Translation**

编译器可将源代码编译成机器码。

首先将源代码解析成解析树，然后将解析树编译成机器码。

**解析类型 parsers type**

- 自上而下，从语法的高层结构出发，尝试从中找到匹配的结构。
- 自下而上的移位归约解析器，从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。

**HTML 解析器**

HTML 无法使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。

浏览器的容错机制有大量的解析器代码会纠正 HTML 网页作者的错误。

- 标记化：起始标记、结束标记、属性名称和属性值。标记生成器识别标记，传递给树构造器。

- 树构建：在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。

**CSS 解析器**

WebKit 使用 [Flex 和 Bison](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#parser_generators) 解析器生成器，通过 CSS 语法文件自动创建解析器。

**script**

浏览器解析是同步的，解析器遇到 `<script>` 标记时立即解析并执行脚本。

可以将 js 脚本设置成 defer，这样不会停止文档解析，而是等到解析结束才执行 js。

**预解析**

在执行脚本时，其他线程会解析文档的其余部分，找出并**加载**需要通过网络加载的其他资源。

预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。

#### 2. Render 树

Render容器是和 DOM 元素是相对应的，但并非一一对应。

- 由**可视化元素**按照其显示顺序而组成的树，非可视化元素`<head>` 和`display:none`。
- 浮动定位和绝对定位，处于正常的流程之外。
- 初始容器 block 为 **viewport**

**样式计算**

- 浏览器的默认样式表
- 网页作者提供的样式表
- 浏览器用户提供的用户样式表

可能存在难点：

1. 样式太多，可能会造成内存问题。
2. 样式匹配，遍历整个规则和无用匹配，可能会造成性能问题。选择器的顺序
3. 层叠规则顺序
   1. 浏览器声明
   2. 用户普通声明
   3. 作者普通声明
   4. 作者重要声明 !important
   5. 用户重要声明

#### 3. Layout 布局

Reader 器在创建完成并添加到呈现树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。HTML 采用基于流的布局模型，后面的不会影响前面的。一般情况只需要一次遍历，也就可以从左至右、从上至下的顺序遍历文档。

- 全局布局，全局样式更改，屏幕大小改变。
- 增量布局，是异步执行的

布局用来计算位置。

#### 4. Painting 绘制

- 全局绘制
- 增量绘制

绘制堆栈顺序（先进后出）：

1. background color
2. background image
3. border
4. children
5. outline

html 元素的字体变化，会导致缓存无效，使得整个 render 树都会进行重新 Layout 和 Painting。

render 引擎（UI渲染）采用的是单线程，但是在浏览器中还可以有其他线程，比如，网络请求通常可以由2-6个并行线程执行。render 引擎的线程就是浏览器的主线程。

浏览器的主线程是**事件循环**，是一个 while 无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。