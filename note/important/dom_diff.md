#### Virtual DOM

DOM 是很慢的。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的，而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。

```js
// 如果我们把一个简单的 div 元素的属性都打印出来，你可以看到非常多的 DOM 元素属性，而这仅仅是第一层
var div = document.createElement('div');
var str = '';
for (var key in div) {
  str = str + key + ' ';
}
console.log(str);
```

相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：**这就是 Virtual DOM**。

虚拟 DOM 的根本目的是 **维护状态，更新视图**

#### dom diff

真实的 DOM 树信息可以用 JS 对象来表示，那么也可以 JS 对象建立的树结构来构建一个真实的 DOM 树。

当状态变更的时候，重新渲染这个 JavaScript 的对象结构。

用新渲染的对象树去和旧的树进行对比，记录这两棵树差异，**这就是 dom diff**，最后根据比较出来的结果，生成真实 DOM 操作。

前端中的比较一般都是同层比较，所以可以把 dom diff 算法复杂度优化到 O(n)

1. 记录节点类型、属性，还有子节点，生成 Virtual DOM
2. 深度优先遍历，通过递归实现，记录新 Virtual DOM 和 旧 Virtual DOM 差异。
3. 通过 dom diff 对比出来之后，打补丁包 patch

**差异类型**

1. 替换掉原来的节点
2. 移动、删除、新增子节点
3. 修改了节点的属性
4. 对于文本节点，文本内容可能会改变。

#### Vue  的 dom diff 优化

1. 头尾一致，指针移动下一个节点。
2. 头或尾一致，头尾交换（根据新 dom 节点的位置，移动老 dom 的节点），指针移动下一个节点。
3. 判断有没有  key，有 key 的话，直接按**索引**取值。
4. 新增的节点，创建节点，然后直接插入到指定位置。
5. 节点类型都不一样， 删除的节点，打个标记 ❌，最后遍历发现带标记的都 remove 掉。
6. 当新virtual dom 两个指针首尾相交，就 diff 结束了。 

#### React 的 dom diff 优化

react 16 从 **reconcile算法 **到 **新的调度算法 Fiber**

Fiber使用协作式多任务处理任务。将原来的整个 Virtual DOM 的更新任务拆分成一个个小的任务。每次做完一个小任务之后，放弃一下自己的执行将主线程空闲出来，看看有没有其他的任务。如果有的话，就暂停本次任务，执行其他的任务，如果没有的话，就继续下一个小任务。

每次组件的state更新都会触发 reconcile 的执行，而reconcile的执行也是一个递归过程，而且一开始直到递归执行完所有节点才停止，因此称为**stack算法**。

原本 React 更新过程是同步的（异步任务最终都要回到同步执行栈），当组件树比较庞大的时候，浏览器主线程被 React 占用，例如用户 input 操作就会卡顿。