#### 异步IO

1. 异步I/O可以消除UI阻塞。

  - 不同的I/O操作花费的时钟周期是不一样的。
  - 文件描述符的管理。
  
2. IO是昂贵的，分布式IO是更加昂贵的，因为操作慢。
3. node 适用于 IO密集型，不适用CPU密集型。

#### Libuv 管理 Event loop

不同操作系统下封装了不同应用程序。 

内部源码其实就是一个while(true)

事件观察者

- idle观察者 process.nextTick()，效率最高，消耗资源小，但会阻塞CPU后续调用
- IO观察者 setTimeout()，精确度不高，可能延迟，因为动用了红黑树，所以消耗资源大
- check观察者 setImmediate()，消耗资源小，也不会阻塞，但是效率最低
- idle观察者 > Promise.then() > IO观察者 > check观察者 

1. Update time 事件循环的开头，作用是获取系统时间，确保 timer 触发的准确性。
2. timer 检查是否有到期的 timer，也就是 setTimeout
3. IO callback 处理异步事件的回调，网络IO、文件IO
4. Idle, prepare 内部的一些动作，和事件循环没什么关系
5. IO poll 选择性运行
6. check 执行 setImmediate 操作
7. close callback 关闭链路

#### V8垃圾回收机制

#### 新生代

**Scavenge**算法，在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查（广度优先遍历） From 空间中存活的对象并复制到 To 空间中，如果有没存活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换（指针上交换），这样 GC 就结束了。

- 当一个对象经过交换5次以上仍然存活时，它就会被认为是生命周期较长的对象。

- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。
- 他的缺点是只能使用堆内存的一半，这是一个典型的空间换时间的办法，但是新生代声明周期较短，恰恰就适合这个算法。

#### 老生代

**Mark-Sweep 是标记清除**，标记那些死亡的对象，然后清除。但是清除过后出现内存不连续的情况，所以我们要使用 Mark-Compact。

**Mark-Compact 标记压缩算法**，将存活的对象移到一边，移动完成后，直接清理边界外的内存。

当 CPU 空间不足的时候会非常的高效。V8 后续还引入了延迟处理，增量处理，并计划引入并行标记处理。

####  常见内存泄漏问题

1. 无限制增长的数组（eg. 变量当缓存）
2. 无限制设置属性和值（eg.对一个变量无限赋值 ）
3. 任何模块内的私有变量和方法均是永驻内存的，闭包 （变量赋值为 null 不会立马 GC, 而是下一次 GC 回收）
4. 大循环，无 GC 机会（递归，循环的时候不敢GC）

#### V8 高效的那些秘密

1. **JIT：**即时编译，编译结果直接是机器语言，而不是字节码。（不是绝对的）
2. **垃圾回收：**借鉴了java VM 精确的垃圾回收管理，其他语言还用的保守回收管理。
因为deno早期基于 GO 的 , GO的垃圾回收机制和 V8 不一样，现在往 Rust 上转了。
3. **内存缓存：**假如 this.a 没有内存缓存的时候，每次取 a 都要对哈希表进行寻址，V8 能知道这个属性的偏移量。
4. **隐藏类 ：** 假如你一直 new 一个 class，在 V8内部其实是一个类。

—max_old_space_size 4096 设置老生带内存，单位MB

—max_new_space_size 设置新生代内存，单位 KB

⚠️重要概念：

- 类型检查、优化、去优化。
  - 二元运算符可以收集函数的类型反馈(type feedback)
  - 在编译阶段提前使用 type feedback 进行动态检查
  - 检查之后，该类型作为动态类型
  - 如果检查失败，进行去优化
  - 去优化之后， 
- 隐藏类 和 内存缓存
  - haveSameMap 可以判断是否共享内存缓存 
- V8 代码调试
  - 可以通过 node 调试

V8 在 5.9 版本以前（2017年4月），使用了两个编译器

1. full-codegen 一个简单的和非常快的编译器，会产生简单个相对较慢的机器码。（先全部转机器码）
2. crankshaft (2010年) 一种更复杂的 JIT 的优化编译器，生成高度优化的代码。（执行一段时间后，性能线程和分析线程，判断哪些能优化，就优化，替换优化前的机器码）

**5.9之前 js 全部转成机器码** ，需要缓存起来，占用内存磁盘空间大，退出 chrome 以后再打开时，需要序列化、反序列化所花费的时间也很长，时间空间成本都接受不了。

 后来 V8 退而求其次，只编译最外层代码，剩下的推迟到第 1 次调用的时候再编译，这会导致一个问题，假如你的 js 代码闭包嵌套了 N 层，会编译 N 次。 （先解析外层，还要解析内层）

**V8 在 5.9 版本之后，回归字节码。**

牺牲时间换空间，减少机器码占用的空间，内存变小了，就可以提前编译所有代码。第二次打开就会变快。

Igniton + Turbofan 将 js 解析成字节码，从字节码开始优化成机器码，需要反优化的时候，反优化到字节码。

#### DSL NLP AST

DSL 领域特定语言，专注于某个应用领域的计算机语言。

- 外部 DSL：宿主应用的代码采用文本解析技术对外部DSL编写的脚本进行解析。如正则表达式、SQL、配置文件。
- 内部 DSL：通用语言的特定语法，用内部DSL写成的脚本是一段特定的合法程序。如PHP、C#、Java、JavaScript

NLP 自然语言的处理，对代码分词。 （词法解析，语法解析）

AST 抽象语法树，是 DSL 抽象语法结构的树状表现形式。

- 遍历AST 树，分为堆栈该进堆就进堆，该进栈就进栈。

- 执行阶段该出栈就出栈event_loop，执行阶段有一些 浏览器提供的 Web API（DOM、AJAX、setTimeout）

#### JS 执行流程

1. js  字符串
2. 通过词法分析，语法分析，解析成 AST
3. AST 编译成 ByteCode
4. ByteCode 把该优化的优化成机器码
5. 执行代码（字节码、机器码 ）
6. 产生 ECStack，创建 GO VO  AO，会用到内存的堆和栈
7. 计算同步、异步任务，进入（浏览器 和 node） event_loop，对微任务、 宏任务进行排序

