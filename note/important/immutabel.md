##  数据结构与算法

#### 算法复杂度

前端一般为了用户好用，都是用空间换时间。

ES6的 Set 是用哈希实现的，时间复杂度是O(n)，存储空间通常是数据的两倍，典型的**空间换时间**。

用 Benchmark 跑分结果，Set和Map的时间基本一致，当数据量小时，for时间更少，但数据量多时 Set 和Map 有优势，因为指数级增长还是挺恐怖的。

#### Immutable

Immutable.js 采用了**持久化数据结构**，保证每一个对象都是不可变的，任何添加、修改、删除等操作都会生成一个新的对象，且通过**结构共享**等方式大幅提高性能。

对象是按引用传递的，所以可以**持久化数据结构**和**结构共享**

- 持久化数据结构：每次修改后我们都会得到一个新的版本，且旧版本可以完好保留。

- 结构共享：对于本次操作没有修改的部分，我们可以直接把相应的旧的节点拷贝过去，这其实就是结构共享。

#### 源码分析

32是个极限，9是个分界点。

- Vector trie 原理是，使用二叉树，将所有值按照顺序，从左到右存放于叶子节点，当需要更新数据
  时，只将其更新路径上的节点生成新的对象，没有改变的节点继续共用。（复用节点 ）
- hash函数，可以把一个值转换成相应数字，接下来HAMT。
- Hash array maps trie 压缩treeImmutablejs 对于 Map

数字分区(Digit partitioning)

位分区(Bit Partitioning) 2^5等于32

2进制效率高，方便进行位移，方便压缩 。

Immutable.js 的 Vector Trie 采用了 32 作为数组的长度，考虑到平时的使用中，查找比更新频次高很多，所以Immutable.js 选择了 32。2叉树时间复杂度是O(log N)，32叉树时间复杂度是O(log32 N)，所以要压树。

- Bitmap 一种数据结构
- HashArrayMapNode，拥有的子节点数量 >16 ，拥有的数组长度为 32
- BitmapIndexedNode，拥有的子节点数量 ≤16 ，拥有的数组长度与子节点数量一致，经由 bitmap压缩
- ValueNode，叶子节点，存储 key 和 value

mt算法

setstate批处理用了浏览器事务 

函子、流式编程、reducer