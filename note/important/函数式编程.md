## 函数式编程

#### 什么是函数式编程？

函数式编程是一种编程范式，范畴论的运算方法，是一种**数学运算**，原始目的就是求值，只是碰巧它能用来写程序。

目标是**使用函数来抽象**作用在数据之上的**控制流与操作**，从而减少副作用和对状态的改变。

- 声明式编程：告诉“机器”你想要的是什么，让机器想出如何去做，强调整体。

- 命令式编程：命令“机器”如何去做事情，这样不管你想要的是什么，它都会按照你的命令实现，强调过程。

#### 纯函数

纯函数具有以下特性：

1. 相同的输入，总有相同的输出。（只取决于函数输入，不管上下文 this、执行多少次、什么时间调用，返回结果都一样）

2. 没有任何可观察的副作用。（不会修改全局的变量、参数或参数引用、异常错误、日志、外部访问等）

纯函数的好处：

1. 可以降低程序复杂度（不纯的函数扩展性差）
2. 可以缓存（第二次命中缓存，速度很快）。

#### 偏函数

偏函数是数学上的一个概念，一种特殊的一元函数。它并不会接受符合参数类型的所有可能值，而是**只接受特定的值**。

#### 偏应用函数

调用函数的过程也叫做将函数应用到参数。

- 当调用时传入了所有的参数，完全应用函数。(fully applied)
- 当在调用时只传入了部分参数，**部分应用函数**(Partially Applied Function)，不会报错，简单应用这些参数并返回一个接受剩余参数的新函数。
- 例如 js 中的 bind 函数，就是一个偏应用函数。

#### 柯里化

可以理解柯里化是偏应用函数的一种特例。

柯里化函数实现**降元**的方式有些不同。将一个接受多个参数的函数分解成一系列的函数（把有 n 个参数的函数，转化为 n 个**嵌套**的函数，类似于洋葱代码，**从内到外，闭包**。），**每个函数只接受一个参数**，这个过程叫做柯里化。

注意：都是给函数**降元**，一个参数是一元，两个参数是二元。

- 偏应用函数：将多个入参的函数转化成两部分，一步是函数，一步是参数（2 步）
- 柯里化：把一个有 n 个参数的函数，变成 n 个只有 1 个参数的函数（n 步）

优点：

1. 灵活，可以连续提供参数。
2. 可重用，易维护
3. 声明式代码，增强了代码可读性

缺点：会占用额外的堆栈空间。

事实上柯里化是一种**"预加载"**函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。

#### 函数组合

范畴论数学中的结合律，将两个函数结合，产生一个新的函数。创建了一个**从右到左**的数据流，解决了函数嵌套，洋葱代码 h(g(f(x))); 的问题。使代码结构更加灵活。

#### point-free

本质是使用一些通用的函数，组合出各种复杂运算。不使用所要处理的值，只合成运算过程。

point-free 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用。

#### 高阶函数

函数也是 new Function() 出来的对象，和普通对象类似，也就能作为参数传递了，或者由其他函数返回。这个就是"函数是一等公民"。

只要满足 2 个中的 1 个就是高阶函数：map、reduce、filter、sort

- 接受一个或多个函数作为**输入**
- **输出一个函数**，单纯的执行函数回调并不是高阶函数。

#### 范畴

我们可以把范畴当作容器，值(value)、值的**变形关系**，也就是函数。

范畴论用函数表达范畴间的关系，**创建一个安全的容器，来存放危险代码**。

#### 容器

函数不仅可以用在在同一个范畴，值的转换，还可以将一个范畴转换为另一个范畴，这就涉及到 Functor函子 。可以简单映射函数的数据类型。

#### Functor

本质上来讲，Functor 只是一个可以将函数应用到容器包裹的值上，并将结果再包裹起来的数据结构。

简单理解就是，将原来容器里的值应用，再包裹到新容器。通过创建一个map 容器（类似副本），安全的访问操作原来容器值，不会改变原来的值。

比如说数组里的 map、filter 方法，就是一个函数到另一个函数的映射。

- 必须是无副作用的
- 必须是可组合的

1. 函子的标志就是容器具有 map 方法，将容器里面的每一个值，映射到另一个容器。

2. 函子有一个 of 方法同来生成新容器，因为 new 命令是命令式编程的方式。

函子实际执行的脏操作的时候，放到外部执行。

- Maybe 函子，处理 null
- Either 函子，处理错误，处理条件运算
- AP 函子，函子里的值有数值，有函数
- IO 函子，处理脏操作，它的 __value 是一个函数。它把不纯的操作(比如 IO、网络请求、DOM)包裹到一个函数内，从而延迟这个操作的执行。

#### Monad

1. 如何处理**嵌套的 Functor **呢? 比如 Maybe(IO(42))
2. 如何处理一个由非纯的或者异步的操作序列呢?

用 Monad 的 flatMap，总是返回一个单层的函子。

flatMap（flat 扁平的 map）本身和 map 类似，如果 map 方法生成了一个嵌套函子，flatMap方法会取出 map 内部的值，flatMap 保证总是返回一个单层的函⼦。

Monad就是一种设计模式，表示将一个运算过程，通过函数拆解成互相连接的多个步骤。你只要提供下一步运算所需的函数，整个运算就会自动进行下去。

- Promise 就是一种 Monad

#### 函数式优化

函数求值策略：

1. 及早求值（贪婪求值）：不管结果是否被用到，函数调用就执行。
2. 惰性求值：函数尽可能的延迟求值，直到依赖的表达式被调用，避免不必要的运算。

- 利用 shortcut fusion 分离描述会和执行，可以合并执行，可以降低内存占用。

- 纯函数语言自带记忆化，归功于函数式的"引用透明性"（函数运行只依赖参数）。问题拆分越小，越容易记忆化

- 递归和尾递归优化

  - 尾调用，最后一步调用另一个函数（最后一个表达式 1+ fn 不算）

  - TCO 尾部调用消除

  -  蹦床函数（trampoline）可以将递归执行转为循环执行。

